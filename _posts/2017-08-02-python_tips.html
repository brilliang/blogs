---
layout: researcher
title: tips in python
---

<h1>always using pyenv</h1>

Install <a href="https://github.com/pyenv/pyenv">pyenv</a> <b>BEFORE</b> installing any version of python yourself.

<p>It is simple to make conflict between python versions used by Operation System and your applications and the unconformity between python and pip. Pyenv holds seperated python environments for your login shell, different folders, and all virtual environments you create.</p>

<h2>install</h2>
<p><a href="https://github.com/pyenv/pyenv-installer">pyenv-installer</a></p>
<p>For apple mac</p>
{% highlight bash %}
brew update
brew install pyenv
brew upgrade pyenv 	# if already installed
brew install --HEAD pyenv-virtualenv
{% endhighlight %}



<h2>USAGE</h2>
{% highlight bash %}
pyenv commands		# list all available commands
pyenv help		# get help for a command
pyenv install -l 	# list all available python versions
pyenv install 3.6.0	# install a specified version of python
pyenv global 3.6.0	# set a global version of python for current user, value is written to ~/.pyenv/version
pyenv local 3.6.0	# set a local version of python for current directory, value is written to ./.python-version
pyenv shell 3.6.0	# set a version of python used in current shell, value is written to a env variable $PYENV_VERSION
{% endhighlight %}

<p>pyenv tries to read python version from $PYENV_VERSION; if fails, then tries to find the file .python-version from current and parents' folders; if fails again, then tries to read from ~/.pyenv/version. </p>

<h2>virtualenv</h2>

<p>If your application needs a different version of <b>library</b>, then virtualenv should be the best choice.</p>

{% highlight bash %}
pyenv virtualenvs			# list all available virtualenvs
pyenv virtualenv [version] env-name	# create a virtualenv. if the version is not specified, then current active version will be used.
pyenv uninstall env-name		# remove a virtualenv.
pyenv activate env-name			# active a virtualenv.
pyenv deactivate			# deactive from current virtualenv.
{% endhighlight %}

<h2>plugins</h2>

Pycharm and zsh both cooperate well with pyenv.

<br />
<hr />
<br />

<h1>string object</h1> 

string object definition in python:

{% highlight python %}
typedef struct {
    PyObject_VAR_HEAD
    long ob_shash;
    int ob_sstate;
    char ob_sval[1];
} PyStringObject;

{% endhighlight %}

there is a array of PyStringObject cached characters in memory, which would shared when you are using a string with 0 or 1 length.

{% highlight python %}
static PyStringObject *characters[UCHAR_MAX + 1];
static PyObject *interned;
{% endhighlight %}

and the field 'ob_sstate' in PyStringObject indicates whether the string in cached by the interned characters cache.


{% highlight python %}
>>> s='a'
>>> a='a'
>>> s == a
True
>>> id(s) == id(a)
True
>>> id('abc'[0]) == id(a)
True
>>> t = 'ab'
>>> id('abc'[:2]) == id(t)
False
{% endhighlight %}
<br />
<hr />
<br />

<h1>some syntactic sugar</h1>
<h2>break when condition matches in a for loop</h2>

{% highlight python %}
for i in the_iterable:
    if condition(i):
        return i
{% endhighlight %}

a more pythonic way:
{% highlight python %}
next( (x for x in the_iterable if x>3), default_value)
{% endhighlight %}



<h1>index and slice in Pyhont and Numpy</h1>

from <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__">python data model</a> we will know that self[key] is implemented within object.__getitem__(self, key). only one key parameters are required.
<br />

In pure Python, integer or slice is used to index list. slice here is a build-in object:
{% highlight python %}
class slice(start, stop[, step])
{% endhighlight %}
<br />

In numpy, we can use a tuple of slice objects and integers to extends Pythonâ€™s basic concept of slicing to N dimensions, one for each dimension. note: x[(exp1, exp2, ..., expN)] is equivalent to x[exp1, exp2, ..., expN]; the latter is just syntactic sugar for the former.

Ellipsis can be used to express omission for the rest of dimension which will use a default slice object of ':' to index all in those dimensions. If the Ellipsis is at end of selection tuple, itself can be omitted.

{% highlight python %}
>>> x = np.array([[[1],[2],[3]], [[4],[5],[6]]])
>>> # x[1, ...], x[1:2], x[1], are all the same
>>> x[1]
array([[4],
       [5],
       [6]])
{% endhighlight %}


